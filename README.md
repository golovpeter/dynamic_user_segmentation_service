# Сервис динамического сегментирования пользователей
## Тестовое задание на стажировку в Avito на позицию Backend developer

`config.yaml` - минимальный файл конфигурации для базы данных и приложения

## Запуск приложения

**Для корректной работы сервиса необходимо указать пароль от базы данных в файле `config.yaml` и  `docker-compose.yaml`-
`postgres`.** 

**Миграции в ручную накатывать не нужно, все происходит автоматически.**

**Затем можно запустить сервис командой:**

```bash
docker compose up 
```

## Документанция

**После запуска сервиса вам станет доступна Swagger документация по адресу - http://localhost:8080/swagger/index.html**

**Предполагаю, что за работу с юзерами отвечает другой микросервис.**

**Методы:**

---

1. **Метод создания сегмента. Принимает slug (название) сегмента, и опционально процент пользователей, который
   обязательно попадут в этот сегмент.**

   **Пример запроса:**
   ```bash
   curl -X POST \
   -H "Content-Type: application/json" \
   -d '{
            "segment_slug": "AVITO_VOICE_MESSAGE"
            "percent_users": 50
   }' \
   http://localhost:8080/v1/segment/create
   ``` 

   **Пример ответа:**

   ```
   200 OK
   ```

---

2. **Метод удаления сегмента. Принимает slug(название) сегмента. После удаления сегмента все пользователи с этим
   сегментом также удаляются.**

   **Пример запроса:**
   ```bash
   curl -X POST \
   -H "Content-Type: application/json" \
   -d '{
       "segment_slug": "AVITO_VOICE_MESSAGE"
   }' \
   http://localhost:8080/v1/segment/delete
   ```

   **Пример ответа:**

   ```
   200 OK
   ```

---

3. **Метод добавления пользователя в сегмент. Принимает список slug (названий) сегментов которые нужно добавить
   пользователю, список slug (названий) сегментов которые нужно удалить у пользователя, id пользователя. Опционально
   принимает время, через которое нужно удалить пользователя из сегментов, в которые его добавляют.**

   **Пример запроса:**
   ```bash
   curl -X POST \
   -H "Content-Type: application/json" \
   -d '{
       "add_segments": [
           "AVITO_VOICE_MESSAGE"
       ],
       "delete_segments": [
           "AVITO_DISCOUNT_30"
       ],
       "user_id": 1003,
       "expired_at": "2023-09-22T23:41:00Z"
   }' \
   http://localhost:8080/v1/segment/changeForUser
   ```

   **Пример ответа:**
   ```
     200 OK
   ```

   **Решение по валидации:**
   
   - **Если добавляемые и удаляемые сегменты имеют пересечение - возвращается ответ с кодом 400, и список пересекающихся
     сегментов**
   
   - **Если какой-либо сегмент не найден в одном из списков - возвращается ответ с кодом 400, и список с ненайденнными
     сегментами**

---

4. **Метод получения активных сегментов пользователя. Принимает на вход id пользователя.**

   **Пример запроса:**

   ```bash
   curl -X GET \
   http://localhost:8080/v1/segments/user/1000 \
   -H "accept: application/json" 
   ```

   **Пример ответа:**

   ```json
   {
     "segments": [
       "AVITO_VOICE_MESSAGE",
       "AVITO_DISCOUNT_30"
     ]
   }
   ```


## Дополнительные задания:

1. **Сохранение истории попадания/выбывания пользователя из сегмента с возможностью получения отчета**.

   До конца реализовать не удалось. Успел добавить только триггер в базу данных на
   удаления и создания сегментов у пользователей, но хотел бы описать логику, которая могла бы быть использована:
    - Создаём триггер в базе данных на удаление и добавление сегментов у пользоваталей
    - Создаём еще дополнительные эндпоинт, который выполняет 2 задачи:
        + Возвращается ссылку на будущий файл или уже на существующий файл.
        + Добавляет задачу в очередь, если файл не существует.
    - Создаём воркер, который бы смотрел, существует ли файл с таким названием (датой, месяцем). Если такой файл уже
      существует - удаляет задачу из очереди, иначе генерирует файл, при этом запрашивая историю бачами из базы.
    - Созданные файлы храним в контейнере, но при масштабировании придется использовать внешнее хранилище, как пример - S3.
    - Создаём еще один эндпоинт, на который отдаётся ссылка в первом. Если файл еще не готов, будем возвращаться
      сообщение об этом.

---

2. **Возможность задавать время нахождения пользователя в сегменте.**

   Реализовано. В методе добавления сегментов можно опционально указать дату, до которой пользователь будет находиться в
   этих
   сегментах. При старте приложения в отдельном контейнере запускается воркер, который с определенным интервалом
   проверяет, не истек ли срок нахождения пользователя в сегменте, в противном случае он удаляет его из этого сегмента.

---

3. **Автоматическое попадание пользователей в сегмент.**

   Реализовано. В методе создания сегмента есть возможность опционально передать процент пользователей, которе должны
   попасть в этот сегмент. Далее, после получения всех сегментов, мы из кэша получаем сегменты, в
   которые должны автоматически распределиться пользователи. Если пользователя еще нету в каком-то из этих сегментов, то
   случайным образом определяем, попадет он туда или нет

   Кэш используется для того, чтобы минимизировать поход в БД за автоматически распределяемыми сегментами и снизить нагрузку на базу, 
   если запросов будет много. Также чтобы уменьшить время ответа ручки. Кэш обновляется каждую минуту, поэтому если вы добавили новый 
   сегмент с процентом пользователей, которые в него должны попать, то пользователи начнут добавляться в него только через минуту.

   **Это задание можно было бы еще оптимизировать. Вместо определения случайным образом попадания пользователя в
   сегмент, можно было бы брать остаток от деления `user_id` на 100 и таким образом определять, попадает ли пользователь
   в
   автоматический сегмент или нет.**
   
    

